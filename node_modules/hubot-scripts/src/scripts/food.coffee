# Description:
#   Food for the masses
#
# Dependencies:
#   "ordrin-api": "0.1.96"
#
# Configuration:
#   None
#
# Commands:
#   food me - Start ordering food
#
# Author:
#   jimtla AND ryandm

_ = require 'underscore'

ordrinApi = require "ordrin-api"

ordrin = ordrinApi.init
  apiKey: "bs9lzpr3hEKefhah-okCW1Vbi8KGcHm5Rgce5Qfkmnc",
  servers: "test"

try
  address = new ordrin.Address "841 Broadway", "New York", "NY", 10014, 4014641931
catch e
  console.log e
  throw e

pretty_json = (object) -> JSON.stringify object, null, 4


new_state = ->
  restaurant: null
  orders: []
  confirmed: false

state = new_state()

join_non_empty = (separator, strings...) ->
  _(strings).without('').join separator

print_restaurants = (restaurants) ->
  lines = [
    "---------- Restaurants -----------"
    for restaurant in restaurants
      join_non_empty ' - ', "#{restaurant.id}. #{restaurant.na}"
  ]
  _(lines).flatten().join '\n'

print_menu = (restaurant) ->
  lines = for category in restaurant.menu
    [
      ''
      join_non_empty ' - ', category.name, category.descrip
      "-----------------------------"
      for item in category.children
          join_non_empty ' - ', "#{item.id}. #{item.name}", item.descrip
    ]
  _(lines).flatten().join '\n'

print_order = (restaurant, orders) ->
  lines = [
    "Ordering from #{restaurant.name}"
    "Phone Number: #{restaurant.cs_contact_phone}"
    "------------ Orders -------------"
    for order, index in orders
      "#{index}.#{order.item.name} (Ordered by #{order.orderer})"
  ]
  _(lines).flatten().join '\n'

trayItem = (itemId, quantity) ->
  {
    itemId: parseInt itemId
    quantity: 1
  }

module.exports = (robot) ->

  getObjsFromFuzz = (fuzz, arrayOfObjWithIds, getObjKeywords) ->
    keywordToIds = {}
    for o in arrayOfObjWithIds
      for k in getObjKeywords o
        keywordToIds[k] ||= []
        keywordToIds[k].push o.id
    filter = require 'fuzzy-filter'
    matched = filter fuzz, (k for k of keywordToIds)
    ids = _.uniq [].concat (keywordToIds[k] for k in matched)...
    (o for o in arrayOfObjWithIds when o.id in ids)
  getRestaurantsFromFuzz = (fuzz, restaurants) ->
    getObjsFromFuzz fuzz, restaurants, (r) -> [r.na ? ''].concat (r.cu ? [])
  getItemsFromFuzz = (fuzz, menu) ->
    getObjsFromFuzz fuzz, (_.flatten _.pluck menu, 'children'), (i) -> [i.name]

  robot.respond /fuzz me ([^ ]*) (.*)/i, (msg) ->
    restaurant_id = msg.match[1]
    ordrin.restaurant.getDetails restaurant_id, (err, restaurant) ->
      if err
        msg.reply pretty_json err
      else
        msg.reply pretty_json getItemsFromFuzz msg.match[2], restaurant.menu
    #ordrin.restaurant.getDeliveryList new Date, address, (err, restaurants) ->
    #  if err
    #    msg.reply pretty_json err
    #  else
    #    msg.reply pretty_json getRestaurantsFromFuzz msg.match[1], restaurants

  robot.respond /food me/i, (msg) ->
    ordrin.restaurant.getDeliveryList new Date, address, (err, restaurants) ->
      if err
        msg.reply pretty_json err
      else
        msg.send print_restaurants restaurants

  robot.respond /order from (.+)/i, (msg) ->
    state = new_state()

    restaurant_id = msg.match[1]
    ordrin.restaurant.getDetails restaurant_id, (err, restaurant) ->
      if err
        msg.reply pretty_json err
      else
        state.restaurant = restaurant
        msg.send print_menu restaurant

  robot.respond /order me (.+)/i, (msg) ->
    if not state.restaurant?
      msg.reply "There is no order in progess. To start an order try `order from <restaurant_id>`"
    else
      state.confirmed = false
      item_id = msg.match[1]

      item = do ->
        for category in state.restaurant.menu
          for item in category.children
            if item.id == item_id
              return item
        null

      if not item?
        msg.reply "No item matched."
      else
        state.orders.push
          orderer: msg.message.user.name
          item: item
        msg.reply "Okay!"

  robot.respond /check order/i, (msg) ->
    state.confirmed = true
    msg.send print_order state.restaurant, state.orders

  robot.respond /order it/i, (msg) ->
    if not state.confirmed
      if state.restaurant?
        state.confirmed = true
        msg.send print_order state.restaurant, state.orders
      else
        msg.reply "There is no order in progess. To start an order try `order from <restaurant_id>`"
    else
      state.confirmed = false

      name = msg.message.user.name.split " "
      firstName = name[0]
      lastName = name[name.length-1]

      total = 0
      tray = {items: []}
      for order in state.orders
        total += parseFloat order.item.price
        tray.items.push trayItem order.item.id ,1
      tip = (total * 0.2).toFixed 2
     # msg.send "#{state.restaurant.rest_partner_id} #{pretty_json tray} #{tip} #{firstName} #{lastName} #{pretty_json address} #{total}"
     #ordrin.order.placeOrder state.restaurant, tray, tip, 'ASAP', firstName, lastName, address, creditCard, user, createUser, callback


  robot.respond '/wat/i', (msg) ->
    msg.send pretty_json state.orders
