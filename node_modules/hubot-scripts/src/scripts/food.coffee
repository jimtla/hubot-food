# Description:
#   Food for the masses
#
# Dependencies:
#   "ordrin-api": "0.1.96"
#
# Configuration:
#   you want to know the configuration? hope you like reading code
#
# Commands:
#   you want to know the commands? hope you like reading code
#
# Author:
#   jimtla AND ryandm AND aelnaiem

_ = require 'underscore'

ordrin = (require "ordrin-api").init
  apiKey: "bs9lzpr3hEKefhah-okCW1Vbi8KGcHm5Rgce5Qfkmnc",
  servers: "test"

tryWithLog = (f) ->
  try
    f()
  catch e
    console.log e
    throw e
address = tryWithLog ->
  new ordrin.Address "841 Broadway", "New York", "NY", 10003, 4014641931
creditCard = tryWithLog ->
  new ordrin.CreditCard "Mastercard", 5, 2014, address, 5519618768429526, 444

pretty_json = (object) -> JSON.stringify object, null, 4

state = null
reset_state = -> state =
  restaurant: null
  restaurant_id: null
  orders: []
  confirmed: false
reset_state()

join_non_empty = (separator, strings...) ->
  _(strings).without('').join separator

print_items = (items) ->
  lines = [
    "--------- Items ------------------"
    for item in items
      join_non_empty ' - ', item.name, item.descrip
  ]
  _(lines).flatten().join '\n'

print_restaurants = (restaurants) ->
  lines = [
    "---------- Restaurants -----------"
    for restaurant in restaurants
      join_non_empty ' - ', "#{restaurant.id}. #{restaurant.na}"
  ]
  _(lines).flatten().join '\n'

print_menu = (restaurant) ->
  lines = for category in restaurant.menu
    [
      ''
      join_non_empty ' - ', category.name, category.descrip
      "-----------------------------"
      for item in category.children
          join_non_empty ' - ', "#{item.id}. #{item.name}", item.descrip
    ]
  _(lines).flatten().join '\n'

print_order = (restaurant, orders) ->
  lines = [
    "Ordering from #{restaurant.name}"
    "Phone Number: #{restaurant.cs_contact_phone}"
    "------------ Orders -------------"
    for order, index in orders
      "#{index}.#{order.item.name} (Ordered by #{order.orderer})"
  ]
  _(lines).flatten().join '\n'

edit_distance = (str0, str1) ->
  score = []
  score[-1] = []
  score[-1][-1] = 0

  for char, idx in str0
    score[idx] = []
    score[idx][-1] = idx + 1

  for char, idx in str1
    score[-1][idx] = idx + 1

  for char0, idx0 in str0
    for char1, idx1 in str1
      score[idx0][idx1] =
        if char0 == char1
          score[idx0 - 1][idx1 - 1]
        else
          Math.min(
              score[idx0 - 1][idx1 - 1]
              score[idx0    ][idx1 - 1]
              score[idx0 - 1][idx1    ]
            ) + 1

  if false # Return back the grid for debug purposes
    output = "    " + ("  #{c} "for c in str0).join ''
    for ot, y in str0
        output += "\n  #{ot}"
        for oc, x in str1
            output += if score[x][y] >= 10 then '' else ' '
            output += " #{score[x][y]} "
    output
  else
    score[str0.length - 1][str1.length - 1]

filter = (keyword, choices, {max_dist, max_count} = {}) ->
  max_dist ?= 7
  max_count ?= 5

  keyword = keyword.toLowerCase()

  make_substrings = (choice) ->
    for index in [0...choice.length]
      prepend_hyphens = Math.max 0, 2 - index
      append_hyphens = Math.max 0, index + keyword.length + 2 - choice.length

      prepend = ('-' for i in [0...prepend_hyphens]).join ''
      append  = ('-' for i in [0...append_hyphens]).join ''

      prepend + choice[Math.max(index-2, 0)...Math.min(index + keyword.length + 2, choice.length)] + append

  scored =
    for choice in choices
      min_distance = Infinity
      for substring in make_substrings choice.toLowerCase()
        distance = edit_distance "**#{keyword}**", substring
        if distance < min_distance
          min_distance = distance

      choice: choice
      distance: min_distance + choice.length/1000



  sorted = _(scored).sortBy ({distance}) -> distance

  if (perfectIsh = sorted[0..1].filter ({distance}) -> distance < 5).length is 1
    #            ^ ... yeah, sorry about that ...
    return _.pluck perfectIsh, 'choice'

  _(sorted[0...max_count]).chain().
    filter(({distance}) -> distance < max_dist).
    pluck('choice').
    value()

module.exports = (robot) ->

  ordrin_prefix = process.env.HUBOT_ORDER_PREFIX ? 'ordrin'

  get_obj_fuzzy = (fuzz, arrayOfObjWithIds, msg, pretty, c, usage, getObjKeywords) ->
    fuzz = fuzz.trim()
    keywordToIds = {}
    for o in arrayOfObjWithIds
      for k in getObjKeywords o
        keywordToIds[k] ||= []
        keywordToIds[k].push o.id
    matched = filter fuzz, (k for k of keywordToIds)
    ids = _.uniq [].concat (keywordToIds[k] for k in matched)...
    objs = (o for o in arrayOfObjWithIds when o.id in ids)
    if objs.length is 1
      c objs[0]
    else if objs.length is 0
      msg.reply "None of the options are a match for `#{fuzz}`."
      usage()
    else
      if fuzz.length is 0
        usage()
      else
        msg.reply "#{objs.length} options are a match for `#{fuzz}` - be more specific?"
        msg.send pretty objs
  get_restaurant_fuzzy = (fuzz, restaurants, msg, pretty, c) ->
    get_obj_fuzzy fuzz, restaurants, msg, pretty, c,
      ->
        msg.reply "Pick a restaurant with: #{ordrin_prefix} <restaurant>"
        msg.send pretty restaurants,
      (r) -> [r.na ? ''].concat (r.cu ? [])
  get_item_fuzzy = (fuzz, menu, msg, pretty, c) ->
    get_obj_fuzzy fuzz, (_.flatten _.pluck menu, 'children'), msg, pretty, c,
      -> "See the menu above for options.",
      (i) -> [i.name]

  unlessErr = (msg, c) ->
    (err, response) -> if err then msg.reply pretty_json err else c response

  responders = []
  respond_to = (regex_string, callback) ->
    responders.push
      regex: new RegExp '^ ?' + regex_string + '$', 'i'
      callback: callback

  robot.hear new RegExp("^#{ordrin_prefix}(.*)", "i"), (msg) ->
    for responder in responders
      match = msg.match[1].match responder.regex
      if match?
        msg.match = match
        responder.callback msg
        return

  respond_to "cancel", (msg) ->
    reset_state()
    msg.reply "Order Cancelled. Choose a new restaurant to order."

  respond_to "it", (msg) ->
    if not state.confirmed
      if state.restaurant?
        state.confirmed = true
        msg.send "Confirm your order! Then `#{ordrin_prefix} it` again!\n" + print_order state.restaurant, state.orders
      else
        msg.reply "There is no order in progess. To start an order try `order from <restaurant_id>`"
    else
      state.confirmed = false

      name = msg.message.user.name.split " "
      firstName = name[0]
      lastName = name[name.length-1]

      total = 0
      tray = tryWithLog -> new ordrin.Tray([])

      tray = tryWithLog ->
        new ordrin.Tray(for order in state.orders
          total += parseFloat order.item.price
          tryWithLog -> new ordrin.TrayItem parseInt(order.item.id), 1, []
        )

      tip = (total * 0.2).toFixed 2
      ordrin.order.placeOrder state.restaurant_id, tray, tip, 'ASAP', firstName, lastName, address, creditCard, {email: 'jimtla@gmail.com'}, false, (err, res) ->
          msg.send "@all Food is on the way!"
          reset_state()

  respond_to "(.*)", (msg) ->
    if state.restaurant? # Choose a dish
      get_item_fuzzy msg.match[1], state.restaurant.menu, msg, print_items,
        (item) ->
          state.confirmed = false
          state.orders.push
            orderer: msg.message.user.name
            item: item
          msg.reply "Okay! I'll get you #{item.name}"
    else # Choose a restauraunt
      ordrin.restaurant.getDeliveryList new Date, address, unlessErr msg, (rs) ->
        get_restaurant_fuzzy msg.match[1], rs, msg, print_restaurants, (restaurant) ->
          ordrin.restaurant.getDetails restaurant.id, unlessErr msg, (details) ->
            state.restaurant = details
            state.restaurant_id = restaurant.id
            msg.send "@all Ordering from #{details.name}! To add your food to the order: #{ordrin_prefix} <menu item>"
            msg.reply "To place the order: #{ordrin_prefix} it"
            msg.send print_menu details
